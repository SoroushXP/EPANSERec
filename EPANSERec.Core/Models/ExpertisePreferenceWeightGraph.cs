namespace EPANSERec.Core.Models;

/// <summary>
/// Represents the expertise preference weight graph for an expert.
/// Generated by the EPDRL module based on historical interactive information.
/// </summary>
public class ExpertisePreferenceWeightGraph
{
    public int ExpertId { get; set; }
    
    /// <summary>
    /// Edge weights between entity pairs - key is (entityId1, entityId2).
    /// </summary>
    private readonly Dictionary<(int, int), float> _edgeWeights = new();
    
    /// <summary>
    /// Entity IDs in this preference graph.
    /// </summary>
    public HashSet<int> EntityIds { get; } = new();
    
    /// <summary>
    /// Self-loop weights for nodes (equation 8 in paper).
    /// </summary>
    private readonly Dictionary<int, float> _selfLoopWeights = new();

    public ExpertisePreferenceWeightGraph(int expertId)
    {
        ExpertId = expertId;
    }

    /// <summary>
    /// Adds or updates an edge weight between two entities.
    /// </summary>
    public void SetEdgeWeight(int entityId1, int entityId2, float weight)
    {
        EntityIds.Add(entityId1);
        EntityIds.Add(entityId2);
        
        // Store bidirectional
        var key1 = (Math.Min(entityId1, entityId2), Math.Max(entityId1, entityId2));
        _edgeWeights[key1] = weight;
    }

    /// <summary>
    /// Gets the edge weight between two entities.
    /// </summary>
    public float GetEdgeWeight(int entityId1, int entityId2)
    {
        var key = (Math.Min(entityId1, entityId2), Math.Max(entityId1, entityId2));
        return _edgeWeights.GetValueOrDefault(key, 0f);
    }

    /// <summary>
    /// Calculates self-loop weight for a node (equation 8).
    /// w(ei) = (1/d(ei)) * sum(wij)
    /// </summary>
    public void CalculateSelfLoopWeights()
    {
        foreach (var entityId in EntityIds)
        {
            var adjacentWeights = _edgeWeights
                .Where(kv => kv.Key.Item1 == entityId || kv.Key.Item2 == entityId)
                .Select(kv => kv.Value)
                .ToList();
                
            if (adjacentWeights.Count > 0)
            {
                float sumWeights = adjacentWeights.Sum();
                _selfLoopWeights[entityId] = sumWeights / adjacentWeights.Count;
            }
            else
            {
                _selfLoopWeights[entityId] = 1.0f;
            }
        }
    }

    /// <summary>
    /// Gets self-loop weight for a node.
    /// </summary>
    public float GetSelfLoopWeight(int entityId) => _selfLoopWeights.GetValueOrDefault(entityId, 1.0f);

    /// <summary>
    /// Normalizes all edge weights to [0, 1] range.
    /// </summary>
    public void NormalizeWeights()
    {
        if (_edgeWeights.Count == 0) return;
        
        float maxWeight = _edgeWeights.Values.Max();
        float minWeight = _edgeWeights.Values.Min();
        float range = maxWeight - minWeight;
        
        if (range > 0)
        {
            var keys = _edgeWeights.Keys.ToList();
            foreach (var key in keys)
            {
                _edgeWeights[key] = (_edgeWeights[key] - minWeight) / range;
            }
        }
    }

    /// <summary>
    /// Gets the adjacency matrix with weights (including self-loops).
    /// </summary>
    public float[,] GetWeightedAdjacencyMatrix()
    {
        var entityList = EntityIds.OrderBy(x => x).ToList();
        var idToIndex = entityList.Select((id, idx) => (id, idx)).ToDictionary(x => x.id, x => x.idx);
        int n = entityList.Count;
        var matrix = new float[n, n];
        
        // Add edge weights
        foreach (var (key, weight) in _edgeWeights)
        {
            if (idToIndex.TryGetValue(key.Item1, out var i) && idToIndex.TryGetValue(key.Item2, out var j))
            {
                matrix[i, j] = weight;
                matrix[j, i] = weight;
            }
        }
        
        // Add self-loop weights
        foreach (var entityId in entityList)
        {
            if (idToIndex.TryGetValue(entityId, out var i))
            {
                matrix[i, i] = GetSelfLoopWeight(entityId);
            }
        }
        
        return matrix;
    }

    public int EdgeCount => _edgeWeights.Count;
}

